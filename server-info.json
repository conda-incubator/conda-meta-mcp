{
  "environment": {
    "fastmcp": "2.13.1",
    "mcp": "1.22.0"
  },
  "serverInfo": {
    "name": "Conda ECO System Meta Data MCP",
    "title": null,
    "version": "2.13.1",
    "websiteUrl": null,
    "icons": null
  },
  "capabilities": {},
  "tools": [
    {
      "name": "cli_help",
      "title": null,
      "description": "Provides the full help text for the given tool including all subcommands and options.\n\nTo be used to answer advanced CLI questions beyond the knowledge cutoff of models,\nto e.g. help with new features that recently landed in the tool.\n\nArgs:\n    tool: str = \"conda\"\n    limit: max number of lines returned (0 means all)\n    offset: number of initial lines skipped\n    grep: Regular expression pattern to filter help lines (case-insensitive).\n          Empty string returns all lines (default).\n          Example: \"install|update|create\" returns lines matching any of these.\n          Reduces context by ~90% for targeted queries.\n\nReturns:\n  A string with the help text",
      "inputSchema": {
        "properties": {
          "tool": {
            "default": "conda",
            "type": "string"
          },
          "limit": {
            "default": 0,
            "type": "integer"
          },
          "offset": {
            "default": 0,
            "type": "integer"
          },
          "grep": {
            "default": "",
            "type": "string"
          }
        },
        "type": "object"
      },
      "outputSchema": {
        "properties": {
          "result": {
            "type": "string"
          }
        },
        "required": [
          "result"
        ],
        "type": "object",
        "x-fastmcp-wrap-result": true
      },
      "icons": null,
      "annotations": null,
      "_meta": {
        "_fastmcp": {
          "tags": []
        }
      }
    },
    {
      "name": "info",
      "title": null,
      "description": "Display version information about the MCP instance.\n\nCan be compared with local output of \"conda info\" to see if they match.\n\nReturns:\n    dict[str, Any]: Version information for MCP instance and dependencies.\n        See InfoResult TypedDict for structure.",
      "inputSchema": {
        "properties": {},
        "type": "object"
      },
      "outputSchema": {
        "additionalProperties": true,
        "type": "object"
      },
      "icons": null,
      "annotations": null,
      "_meta": {
        "_fastmcp": {
          "tags": []
        }
      }
    },
    {
      "name": "package_insights",
      "title": null,
      "description": "Provides insights into a package's info tarball\n\nThat includes the rendered recipe (meta.yaml) that allows for easy inspection of the\npackage's build process, e.g. see build, host and run time dependencies. Which have\nbig influence on what packages are linked against. The run_exports which end up as\nrun time dependencies for other packages linked against this package. And the about\ninformation which contain the remote_url and sha to the repo location where the\npackage recipe is maintained. That helps to open PRs in the right location to fix\nissues with the recipe.\n\nArgs:\n  url: The full package URL, e.g.\n  \"https://conda.anaconda.org/conda-forge/linux-64/numpy-1.24.3-py311h7f8727e_0.tar.bz2\"\n\n  file: can be set to \"some\", \"all\", \"list-without-content\" or a specific filename\n  limit: max number of lines returned per file (0 means all; ignored for\n    list-without-content)\n  offset: number of initial lines skipped per file (ignored for\n    list-without-content)\n   get_keys: Comma-separated keys to extract from parsed file content (YAML/JSON).\n            Empty string returns full file content (default).\n            Example: \"channels,conda_build_version\" extracts those fields from\n            about.json. Requires exactly one file (use 'file' parameter).\n            Significantly reduces context by returning only needed fields.\n   Returns:\n     A dictionary with key=filename, value=content or parsed object.",
      "inputSchema": {
        "properties": {
          "url": {
            "type": "string"
          },
          "file": {
            "default": "some",
            "type": "string"
          },
          "limit": {
            "default": 0,
            "type": "integer"
          },
          "offset": {
            "default": 0,
            "type": "integer"
          },
          "get_keys": {
            "default": "",
            "type": "string"
          }
        },
        "required": [
          "url"
        ],
        "type": "object"
      },
      "outputSchema": {
        "additionalProperties": true,
        "type": "object"
      },
      "icons": null,
      "annotations": null,
      "_meta": {
        "_fastmcp": {
          "tags": []
        }
      }
    },
    {
      "name": "package_search",
      "title": null,
      "description": "Search available conda packages matching the given package_ref_or_match_spec, channel, and\nplatform.\n\nFeatures:\n  - Results are deduplicated.\n  - Ordered by newest (version, then build_number descending).\n  - limit=1 reliably returns the single newest record.\n  - Supports paging via (offset, limit).\n  - Optional field filtering via get_keys parameter.\n\nArgs:\n  package_ref_or_match_spec (PackageRef or MatchSpec or str):\n    e.g. \"numpy\", \"numpy>=1.20\", \"numpy=1.20.3\", \"numpy=1.20.3=py38h550f1ac_0\"\n  channel (str): e.g. \"defaults\", \"conda-forge\", \"bioconda\", \"nvidia\"\n  platform (str): e.g. \"linux-64\", \"linux-aarch64\", \"osx-64\", \"osx-arm64\", \"win-64\"\n  limit (int): Maximum number of results to return (0 means all).\n  offset (int): Number of results to skip before applying limit (for paging).\n  get_keys (str): Comma-separated field names to include in results.\n                 Empty string returns all fields (default).\n                 Example: \"version,build,url\" reduces context by ~60-70%.\n\nReturns:\n  dict with keys:\n    - results: list of package records (filtered by get_keys if specified)\n    - total: total number of matching packages\n    - limit: limit used in this query\n    - offset: offset used in this query",
      "inputSchema": {
        "properties": {
          "package_ref_or_match_spec": {
            "type": "string"
          },
          "channel": {
            "type": "string"
          },
          "platform": {
            "type": "string"
          },
          "limit": {
            "default": 0,
            "type": "integer"
          },
          "offset": {
            "default": 0,
            "type": "integer"
          },
          "get_keys": {
            "default": "",
            "type": "string"
          }
        },
        "required": [
          "package_ref_or_match_spec",
          "channel",
          "platform"
        ],
        "type": "object"
      },
      "outputSchema": {
        "additionalProperties": true,
        "type": "object"
      },
      "icons": null,
      "annotations": null,
      "_meta": {
        "_fastmcp": {
          "tags": []
        }
      }
    },
    {
      "name": "repoquery",
      "title": null,
      "description": "Run a conda repoquery (depends | whoneeds) for a single spec\nand channel. Installed packages excluded. Supports pagination via offset/limit.\n- depends/whoneeds: raw structure unpaginated; sliced pkgs list with offset/limit/total\n  when paginated\n\nArgs:\n    subcmd (str): e.g. \"depends\": show dependencies of this package,\n                       \"whoneeds\": show packages that depend on this package.\n    channel (str): e.g. \"defaults\", \"conda-forge\", \"bioconda\", \"nvidia\"\n    platform (str): e.g. \"linux-64\", \"linux-aarch64\", \"osx-64\", \"osx-arm64\", \"win-64\"\n    limit (int): for pagination / slicing\n    offset (int): for pagination / slicing\n    get_keys (str): Comma-separated field names to include in results.\n                   Empty string returns all fields (default).\n                   Example: \"name,version,url,license\" reduces context by ~60-80%.",
      "inputSchema": {
        "properties": {
          "subcmd": {
            "type": "string"
          },
          "spec": {
            "type": "string"
          },
          "channel": {
            "type": "string"
          },
          "platform": {
            "default": "linux-64",
            "type": "string"
          },
          "tree": {
            "default": false,
            "type": "boolean"
          },
          "offset": {
            "default": 0,
            "type": "integer"
          },
          "limit": {
            "default": 30,
            "type": "integer"
          },
          "get_keys": {
            "default": "",
            "type": "string"
          }
        },
        "required": [
          "subcmd",
          "spec",
          "channel"
        ],
        "type": "object"
      },
      "outputSchema": {
        "additionalProperties": true,
        "type": "object"
      },
      "icons": null,
      "annotations": null,
      "_meta": {
        "_fastmcp": {
          "tags": []
        }
      }
    },
    {
      "name": "import_mapping",
      "title": null,
      "description": "Map a (possibly dotted) Python import name to the most likely conda package\nand expose supporting context.\n\nWhat this does:\n  - Normalizes the import to its top-level module (e.g. \"numpy.linalg\" -> \"numpy\")\n  - Retrieves an approximate candidate set of conda packages that may provide it\n  - Applies a heuristic to pick a single \"best\" package\n  - Returns a structured result with the decision rationale\n\nHeuristic labels:\n  - identity:          No candidates known; fallback to normalized import\n  - identity_present:  Candidates exist AND the normalized import name is among them\n  - ranked_selection:  Best package chosen via ranked hubs authorities ordering\n  - fallback:          Best package not in candidates (unexpected edge case)\n\nReturns:\n  dict with structure matching ImportMappingResult TypedDict:\n    - query_import: original query string supplied by caller\n    - normalized_import: top-level portion used for lookup\n    - best_package: chosen conda package name (may equal normalized_import)\n    - candidate_packages: sorted list of possible supplying packages (may be empty)\n    - heuristic: one of the heuristic labels above\n\nArgs:\n  import_name:\n    Import string, e.g. \"yaml\", \"matplotlib.pyplot\", \"sklearn.model_selection\".\n  get_keys:\n    Comma-separated field names to include in results.\n    Empty string returns all fields (default).\n    Example: \"best_package,heuristic\" returns only key fields.",
      "inputSchema": {
        "properties": {
          "import_name": {
            "type": "string"
          },
          "get_keys": {
            "default": "",
            "type": "string"
          }
        },
        "required": [
          "import_name"
        ],
        "type": "object"
      },
      "outputSchema": {
        "additionalProperties": true,
        "type": "object"
      },
      "icons": null,
      "annotations": null,
      "_meta": {
        "_fastmcp": {
          "tags": []
        }
      }
    },
    {
      "name": "pypi_to_conda",
      "title": null,
      "description": "Map a (case-sensitive) PyPI distribution name to the most likely conda package name.\n\nReturns:\n  dict with structure matching PyPiToCondaResult TypedDict:\n    - pypi_name: original input (trimmed)\n    - conda_name: mapped (lowercase) conda name (fallback: pypi_name.lower())\n    - changed: conda_name != pypi_name.lower()\n\n'changed' is True only when the resolved conda name differs from simple lowercase.",
      "inputSchema": {
        "properties": {
          "pypi_name": {
            "type": "string"
          }
        },
        "required": [
          "pypi_name"
        ],
        "type": "object"
      },
      "outputSchema": {
        "additionalProperties": true,
        "type": "object"
      },
      "icons": null,
      "annotations": null,
      "_meta": {
        "_fastmcp": {
          "tags": []
        }
      }
    },
    {
      "name": "cache_maintenance",
      "title": null,
      "description": "Run cache maintenance for all registered external and tool-level caches.\n\nReturns a short status message after cleanup has been triggered.",
      "inputSchema": {
        "properties": {},
        "type": "object"
      },
      "outputSchema": {
        "properties": {
          "result": {
            "type": "string"
          }
        },
        "required": [
          "result"
        ],
        "type": "object",
        "x-fastmcp-wrap-result": true
      },
      "icons": null,
      "annotations": null,
      "_meta": {
        "_fastmcp": {
          "tags": []
        }
      }
    }
  ],
  "prompts": [],
  "resources": [],
  "resourceTemplates": []
}